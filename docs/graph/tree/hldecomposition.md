## 概要

木上のクエリを効率よく捌くための前処理.

## 計算量

* 構築 : $O(N)$
* クエリ : $O(\log N)$

## 変数

頂点$0$を根とした根付き木として計算する.

* `sub`  : 部分木のサイズ
* `dep`  : 深さ (0-origin)
* `dst`  : 根からの距離 (重みが$1$なら`dep`と同じ)
* `par`  : 親の頂点番号
* `head` : 属するheavy-pathの最初の頂点番号
* `in`   : オイラーツアーしたときの左端
* `out`  : オイラーツアーしたときの右端
* `rev`  : `in`の逆写像

## 使用例

* `HLDecomposition<int> hld(V)` : 頂点数$V$のグラフを生成
  * 入力はグラフを参照
* `hld.build(r = 0)` : 頂点$r$を根として構築
* `hld.lca(u, v)` : $u$と$v$の最小共通祖先を取得
* `hld.dist(u, v)`  : パスの距離を取得
* `hld.get_path(u, v)` : $u, v$間のパスに対応する頂点番号ペア群 (半開区間)
  * 辺属性なら第3引数を`true`にする
* `hld.get_subtree(u)` : $u$を根とする部分木の頂点番号ペア (半開区間)
  * 辺属性なら第2引数を`true`にする
